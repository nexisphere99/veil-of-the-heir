
:: MemoryGame
<script>
// Memory Game Configuration
window.memoryGameConfig = {
    gridWidth: 3,  // Number of columns
    gridHeight: 4, // Number of rows
    imageCount: 12, // Number of different images (must be <= (width*height)/2)
    maxWidth: getMaxWidth(),  // Maximum width of game board
    gameTime: 120   // Game time in seconds
};
console.log(window.memoryGameConfig.maxWidth)
// Function to determine max width based on screen size
function getMaxWidth() {
    const screenWidth = window.innerWidth;
    if (screenWidth <= 480) {
        return 270; // Mobile
    } else if (screenWidth <= 768) {
        return 400; // Tablet
    } else if (screenWidth <= 1800) {
        return 600; // Laptop
    } else {
        return 900; // Desktop
    }
}



// Game state
window.memoryGame = {
  cards: [],
  flippedCards: [],
  matchedPairs: 0,
  gameStarted: false,
  timer: null,
  timeLeft: 0,
  totalPairs: 0
};

// Initialize the game
window.initMemoryGame = function() {
  // Clear any existing timer
  if (memoryGame.timer) {
    clearInterval(memoryGame.timer);
    memoryGame.timer = null;
  }
  
  // Calculate total pairs (must be even number)
  memoryGame.totalPairs = (memoryGameConfig.gridWidth * memoryGameConfig.gridHeight) / 2;
  if (memoryGameConfig.imageCount > memoryGame.totalPairs) {
    memoryGameConfig.imageCount = memoryGame.totalPairs;
  }
  
  memoryGame.matchedPairs = 0;
  memoryGame.flippedCards = [];
  memoryGame.gameStarted = false;
  memoryGame.timeLeft = memoryGameConfig.gameTime;
  
  // Create card pairs as objects
  let cardValues = [];
  for (let i = 0; i < memoryGame.totalPairs; i++) {
    const value = i % memoryGameConfig.imageCount;
    cardValues.push({ value: value, matched: false });
    cardValues.push({ value: value, matched: false });
  }
  
  memoryGame.cards = shuffleArray(cardValues);
  updateGameUI();
  updateTimerDisplay();
  
  // Properly bind event listeners in SugarCube
  $(document).on('click', '.memory-card', function() {
    const index = parseInt(this.getAttribute('data-index'));
    flipCard(index);
  });
};

// Shuffle function
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Card click handler
window.flipCard = function(index) {
  // Start timer on first move
  if (memoryGame.flippedCards.length === 0) {
    if (!memoryGame.gameStarted) {
      memoryGame.gameStarted = true;
      startTimer();
    }
  }
  // Don't allow flipping if invalid
  if (!memoryGame.gameStarted || 
      memoryGame.flippedCards.includes(index) || 
      memoryGame.cards[index].matched || 
      memoryGame.flippedCards.length >= 2) {
    return;
  }

  // Flip the card
  memoryGame.flippedCards.push(index);
  updateGameUI();

  // Check for match if two cards are flipped
  if (memoryGame.flippedCards.length === 2) {
    const card1 = memoryGame.cards[memoryGame.flippedCards[0]];
    const card2 = memoryGame.cards[memoryGame.flippedCards[1]];
    
    if (card1.value === card2.value) {
      // Match found
      card1.matched = true;
      card2.matched = true;
      memoryGame.matchedPairs++;
      memoryGame.flippedCards = [];
      
      // Check for win
      if (memoryGame.matchedPairs === memoryGame.totalPairs) {
        setTimeout(() => endGame(true), 500);
      }
    } else {
      // No match - flip back after delay
      setTimeout(() => {
        memoryGame.flippedCards = [];
        updateGameUI();
      }, 1000);
    }
    updateGameUI();
  }
};

// Update game UI
function updateGameUI() {
  const gameBoard = $('#memory-game-board')[0];
  if (!gameBoard) return;
  
  // Calculate card size based on width and max width
  const cardWidth = Math.floor(memoryGameConfig.maxWidth / memoryGameConfig.gridWidth);
//   const cardHeight = cardWidth * 1.2; // Make cards slightly taller than wide
  const cardHeight = cardWidth; // Make cards slightly taller than wide

  
  gameBoard.style.width = `${cardWidth * memoryGameConfig.gridWidth}px`;
  gameBoard.style.height = `${cardHeight * memoryGameConfig.gridHeight}px`;
  
  let html = '';
  memoryGame.cards.forEach((card, index) => {
    const isFlipped = memoryGame.flippedCards.includes(index) || card.matched;
    const imgSrc = `https://picsum.photos/seed/${card.value}/300/300`;
    
    html += `
      <div class="memory-card" 
           style="width: ${cardWidth}px; height: ${cardHeight}px;"
           data-index="${index}">
        <div class="memory-card-inner" style="transform: rotateY(${isFlipped ? '180deg' : '0deg'});">
          <div class="memory-card-front"></div>
          <div class="memory-card-back" style="background-image: url('${imgSrc}')"></div>
        </div>
      </div>
    `;
  });
  
  gameBoard.innerHTML = html;
  
  // Update progress
  const progress = (memoryGame.matchedPairs / memoryGame.totalPairs) * 100;
  $('#memory-progress-bar').css('width', `${progress}%`)
                          .text(`${memoryGame.matchedPairs}/${memoryGame.totalPairs} Pairs`);
}

// Timer functions
function startTimer() {
  // Clear any existing timer first
  if (memoryGame.timer) {
    clearInterval(memoryGame.timer);
  }
  
  memoryGame.timer = setInterval(() => {
    memoryGame.timeLeft--;
    updateTimerDisplay();
    if (memoryGame.timeLeft <= 0) endGame(false);
  }, 1000);
}

function updateTimerDisplay() {
  const minutes = Math.floor(memoryGame.timeLeft / 60);
  const seconds = memoryGame.timeLeft % 60;
  $('#memory-timer').text(`${minutes}:${seconds < 10 ? '0' : ''}${seconds}`);
}

function endGame(win) {
  clearInterval(memoryGame.timer);
  alert(win ? 'Congratulations! You won!' : "Time's up! Game over.");
}

// Reveal all cards
window.revealAllCards = function() {
  // Check if all non-matched cards are already revealed
  const allNonMatchedRevealed = memoryGame.cards.every((card, index) => 
    card === null || memoryGame.flippedCards.includes(index)
  );
  
  if (allNonMatchedRevealed) {
    // If already revealed, hide all non-matched cards
    memoryGame.flippedCards = memoryGame.flippedCards.filter(index => 
      memoryGame.cards[index] === null
    );
  } else {
    // If not revealed, reveal all non-matched cards
    memoryGame.flippedCards = [];
    memoryGame.cards.forEach((card, index) => {
      if (card !== null) memoryGame.flippedCards.push(index);
    });
  }
  
  updateGameUI();
};

// Change settings
window.changeGameSettings = function() {
  const newWidth = parseInt(prompt('Grid width (columns):', memoryGameConfig.gridWidth));
  const newHeight = parseInt(prompt('Grid height (rows):', memoryGameConfig.gridHeight));
  const newImages = parseInt(prompt('Number of images:', memoryGameConfig.imageCount));
  const newTime = parseInt(prompt('Game time (seconds):', memoryGameConfig.gameTime));
  
  // Validate inputs
  const totalCards = newWidth * newHeight;
  if (newWidth && newHeight && newImages && newTime && 
      totalCards % 2 === 0 && 
      newImages <= totalCards/2) {
    memoryGameConfig.gridWidth = newWidth;
    memoryGameConfig.gridHeight = newHeight;
    memoryGameConfig.imageCount = newImages;
    memoryGameConfig.gameTime = newTime;
    initMemoryGame();
  } else {
    alert('Invalid settings. Please make sure:\n- Width × Height is an even number\n- Image count ≤ (Width × Height)/2');
  }
};
</script>

<style>
#memory-game-container {
  max-width: 600px;
  margin: 0 auto;
  font-family: Arial, sans-serif;
  text-align: center;
}

#memory-game-controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 15px;
}

.memory-game-button {
  padding: 8px 15px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.memory-game-button:hover {
  background: #45a049;
}

#memory-progress-container {
  background: #f1f1f1;
  border-radius: 4px;
  margin: 10px 0;
}

#memory-progress-bar {
  height: 24px;
  background: #4CAF50;
  border-radius: 4px;
  color: white;
  line-height: 24px;
  width: 0%;
  transition: width 0.3s;
}

#memory-game-board {
  display: flex;
  flex-wrap: wrap;
  margin: 0 auto;
  perspective: 1000px;
}

.memory-card {
  margin: 0;
  position: relative;
  cursor: pointer;
  transform-style: preserve-3d;
}

.memory-card-inner {
  position: relative;
  width: 100%;
  height: 100%;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.memory-card-front, .memory-card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  border-radius: 5px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.memory-card-front {
  background: #3498db;
}

.memory-card-back {
  background: white;
  background-size: cover;
  background-position: center;
  transform: rotateY(180deg);
}

#memory-timer {
  font-size: 24px;
  font-weight: bold;
  margin: 10px 0;
}
</style>

<div id="memory-game-container">
  <h2>Memory Matching Game</h2>
  
  <div id="memory-game-controls">
    <button class="memory-game-button" onclick="initMemoryGame()">New Game</button>
    <button class="memory-game-button" onclick="changeGameSettings()">Settings</button>
    <button class="memory-game-button" onclick="revealAllCards()">Reveal All</button>
  </div>
  
  <div id="memory-progress-container">
    <div id="memory-progress-bar">0/0 Pairs</div>
  </div>
  
  <div id="memory-timer">2:00</div>
  
  <div id="memory-game-board"></div>
</div>

<script>
// Initialize game when passage loads
$(document).ready(function() {
  initMemoryGame();
});
</script>